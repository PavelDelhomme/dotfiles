# ~/dotfiles/zsh/zshrc_custom - VERSION RÃ‰ORGANISÃ‰E

# Restaurer le PATH original si nÃ©cessaire
if [ -n "$PATH_ORIGINAL" ]; then
	export PATH=$PATH_ORIGINAL
fi

DOTFILES_PATH="$HOME/dotfiles/"
DOTFILES_ZSH_PATH="$DOTFILES_PATH/zsh/"
ENV_FILE="$DOTFILES_ZSH_PATH/env.sh"
ALIASES_FILES="$DOTFILES_ZSH_PATH/aliases.zsh"
FUNCTIONS_DIR="$DOTFILES_ZSH_PATH/functions/"

# =============================================================================
# CONFIGURATION NVM (Node Version Manager)
# IMPORTANT: Cette configuration doit Ãªtre placÃ©e AVANT l'activation d'Oh-My-Zsh
# pour Ã©viter les bugs d'accÃ¨s. Utilise le lazy-loading pour accÃ©lÃ©rer le dÃ©marrage.
# =============================================================================
export NVM_DIR="$HOME/.nvm"

# Lazy-loading NVM (ne charge NVM que quand on utilise node/npm/nvm/npx)
lazynvm() {
  unset -f nvm node npm npx
  export NVM_DIR="$HOME/.nvm"
  [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
}

# Wrappers pour lazy-loading
nvm() { lazynvm; nvm "$@"; }
node() { lazynvm; node "$@"; }
npm()  { lazynvm; npm  "$@"; }
npx()  { lazynvm; npx  "$@"; }

# Couleurs pour messages
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# =============================================================================
# Ã‰TAPE 1 : CHARGEMENT DU GESTIONNAIRE DE MODULES (MODULEMAN) EN PREMIER
# IMPORTANT: Moduleman doit Ãªtre chargÃ© en premier pour gÃ©rer l'activation/dÃ©sactivation
# =============================================================================
MODULEMAN_CONFIG_FILE="$HOME/dotfiles/.config/moduleman/modules.conf"
if [ -f "$MODULEMAN_CONFIG_FILE" ]; then
    source "$MODULEMAN_CONFIG_FILE" 2>/dev/null || true
fi

# Charger moduleman pour gÃ©rer les modules
[ -f "$DOTFILES_ZSH_PATH/functions/moduleman.zsh" ] && source "$DOTFILES_ZSH_PATH/functions/moduleman.zsh" 2>/dev/null || true

# =============================================================================
# Ã‰TAPE 2 : CHARGEMENT DES GESTIONNAIRES (*MAN) SELON LA CONFIGURATION
# IMPORTANT: Ces gestionnaires doivent Ãªtre chargÃ©s AVANT env.sh
# car env.sh utilise add_to_path() qui est dÃ©finie dans pathman.zsh
# =============================================================================
echo -e "${CYAN}ğŸš€ Ã‰TAPE 1/5 : Chargement des gestionnaires...${NC}"

# Fonction pour charger un manager si activÃ©
load_manager() {
    local manager_name="$1"
    local manager_file="$2"
    local display_name="$3"
    local var_name="MODULE_${manager_name}"
    local module_status="${(P)var_name:-enabled}"
    
    if [ "$module_status" = "enabled" ]; then
        if [ -f "$manager_file" ]; then
            source "$manager_file" && echo -e "${GREEN}  âœ”ï¸ $display_name chargÃ©${NC}" || echo -e "${YELLOW}  âš ï¸ $display_name introuvable${NC}"
        else
            echo -e "${YELLOW}  âš ï¸ $display_name introuvable${NC}"
        fi
    else
        echo -e "${YELLOW}  âš ï¸ $display_name dÃ©sactivÃ© (moduleman)${NC}"
    fi
}

load_manager "pathman" "$DOTFILES_ZSH_PATH/functions/pathman.zsh" "PATHMAN"
load_manager "netman" "$DOTFILES_ZSH_PATH/functions/netman.zsh" "NETMAN"
load_manager "aliaman" "$DOTFILES_ZSH_PATH/functions/aliaman.zsh" "ALIAMAN"
load_manager "miscman" "$DOTFILES_ZSH_PATH/functions/miscman.zsh" "MISCMAN"
load_manager "searchman" "$DOTFILES_ZSH_PATH/functions/searchman.zsh" "SEARCHMAN"
load_manager "cyberman" "$DOTFILES_ZSH_PATH/functions/cyberman.zsh" "CYBERMAN"
load_manager "devman" "$DOTFILES_ZSH_PATH/functions/devman.zsh" "DEVMAN"
load_manager "gitman" "$DOTFILES_ZSH_PATH/functions/gitman.zsh" "GITMAN"
load_manager "helpman" "$DOTFILES_ZSH_PATH/functions/helpman.zsh" "HELPMAN"
load_manager "manman" "$DOTFILES_ZSH_PATH/functions/manman.zsh" "MANMAN"
load_manager "configman" "$DOTFILES_ZSH_PATH/functions/configman.zsh" "CONFIGMAN"
load_manager "installman" "$DOTFILES_ZSH_PATH/functions/installman.zsh" "INSTALLMAN"
load_manager "moduleman" "$DOTFILES_ZSH_PATH/functions/moduleman.zsh" "MODULEMAN"

# =============================================================================
# Ã‰TAPE 2 : CHARGEMENT DES VARIABLES D'ENVIRONNEMENT
# IMPORTANT: env.sh doit Ãªtre chargÃ© APRÃˆS les gestionnaires car il utilise
# add_to_path() dÃ©finie dans pathman.zsh pour ajouter des chemins au PATH
# =============================================================================
echo -e "${CYAN}ğŸ“¦ Ã‰TAPE 2/5 : Chargement des variables d'environnement...${NC}"
if [ -f "$ENV_FILE" ]; then
    source "$ENV_FILE"
    echo -e "${GREEN}  âœ”ï¸ Variables d'environnement chargÃ©es${NC}"
else
    echo -e "${YELLOW}  âš ï¸ Fichier $ENV_FILE introuvable${NC}"
fi

# =============================================================================
# Ã‰TAPE 4 : CHARGEMENT DES FONCTIONS INDIVIDUELLES
# Charge toutes les fonctions depuis les sous-dossiers organisÃ©s :
# - cyber/ (rÃ©organisÃ© en reconnaissance/, scanning/, vulnerability/, attacks/, analysis/, privacy/)
# - dev/, git/, misc/, network/, utils/
# =============================================================================
echo -e "${CYAN}ğŸ”§ Ã‰TAPE 3/5 : Chargement des fonctions individuelles...${NC}"

# Charger update_system.sh en premier pour remplacer les alias update/upgrade
# Supprimer les alias s'ils existent avant de charger la fonction
if [ -f "$FUNCTIONS_DIR/misc/system/update_system.sh" ]; then
    unalias update 2>/dev/null || true
    unalias upgrade 2>/dev/null || true
    source "$FUNCTIONS_DIR/misc/system/update_system.sh" 2>/dev/null && echo -e "${GREEN}  âœ”ï¸ update_system chargÃ©${NC}" || echo -e "${YELLOW}  âš ï¸ update_system introuvable${NC}"
fi

if [ -d "$FUNCTIONS_DIR" ]; then
    local loaded_count=0
    local error_count=0
    
    # Charger installman et configman en premier (gestionnaires d'installation/configuration)
    # VÃ©rifier si activÃ©s via moduleman
    local installman_status="${MODULE_installman:-enabled}"
    local configman_status="${MODULE_configman:-enabled}"
    
    if [ "$installman_status" = "enabled" ] && [ -f "$FUNCTIONS_DIR/installman.zsh" ]; then
        source "$FUNCTIONS_DIR/installman.zsh" 2>/dev/null && ((loaded_count++)) || ((error_count++))
    elif [ "$installman_status" = "disabled" ]; then
        echo -e "${YELLOW}  âš ï¸ INSTALLMAN dÃ©sactivÃ© (moduleman)${NC}"
    fi
    
    if [ "$configman_status" = "enabled" ] && [ -f "$FUNCTIONS_DIR/configman.zsh" ]; then
        source "$FUNCTIONS_DIR/configman.zsh" 2>/dev/null && ((loaded_count++)) || ((error_count++))
    elif [ "$configman_status" = "disabled" ]; then
        echo -e "${YELLOW}  âš ï¸ CONFIGMAN dÃ©sactivÃ© (moduleman)${NC}"
    fi
    
    # Charger rÃ©cursivement tous les scripts .sh et .zsh
    for func_file in "$FUNCTIONS_DIR"/**/*.sh "$FUNCTIONS_DIR"/**/*.zsh; do
        # Ignore les gestionnaires dÃ©jÃ  chargÃ©s, les backups, les sous-dossiers de cyber, alias_utils, update_system, install-tool, et les scripts d'installation
        if [[ "$func_file" != *"man.zsh" ]] && \
           [[ "$func_file" != *"backup"* ]] && \
           [[ "$func_file" != *"/cyber/"*.zsh ]] && \
           [[ "$func_file" != *"alias_utils.zsh" ]] && \
           [[ "$func_file" != *"update_system.sh" ]] && \
           [[ "$func_file" != *"install-tool.zsh" ]] && \
           [[ "$func_file" != *"installman.zsh" ]] && \
           [[ "$func_file" != *"configman.zsh" ]] && \
           [[ "$func_file" != *"/install/"* ]] && \
           [ -f "$func_file" ]; then
            if source "$func_file" 2>/dev/null; then
                ((loaded_count++))
            else
                ((error_count++))
                echo -e "${YELLOW}  âš ï¸ Erreur: $(basename "$func_file")${NC}" >&2
            fi
        fi
    done
    echo -e "${GREEN}  âœ”ï¸ $loaded_count fonctions chargÃ©es${NC}"
    [ $error_count -gt 0 ] && echo -e "${YELLOW}  âš ï¸ $error_count erreurs${NC}"
else
    echo -e "${YELLOW}  âš ï¸ RÃ©pertoire de fonctions introuvable : $FUNCTIONS_DIR${NC}"
fi

# =============================================================================
# Ã‰TAPE 5 : CHARGEMENT DES UTILITAIRES (alias, logs, documentation)
# =============================================================================
echo -e "${CYAN}ğŸ“ Ã‰TAPE 4/5 : Chargement des utilitaires...${NC}"
[ -f "$DOTFILES_ZSH_PATH/functions/utils/alias_utils.zsh" ] && source "$DOTFILES_ZSH_PATH/functions/utils/alias_utils.zsh" && echo -e "${GREEN}  âœ”ï¸ Alias utils chargÃ©s${NC}" || echo -e "${YELLOW}  âš ï¸ Alias utils introuvable${NC}"
[ -f "$DOTFILES_PATH/scripts/lib/actions_logger.sh" ] && source "$DOTFILES_PATH/scripts/lib/actions_logger.sh" && echo -e "${GREEN}  âœ”ï¸ Actions logger chargÃ©${NC}" || echo -e "${YELLOW}  âš ï¸ Actions logger introuvable${NC}"
[ -f "$DOTFILES_ZSH_PATH/functions/helpman/modules/help_system.sh" ] && source "$DOTFILES_ZSH_PATH/functions/helpman/modules/help_system.sh" && echo -e "${GREEN}  âœ”ï¸ SystÃ¨me d'aide chargÃ©${NC}" || echo -e "${YELLOW}  âš ï¸ SystÃ¨me d'aide introuvable${NC}"

# =============================================================================
# Ã‰TAPE 6 : CHARGEMENT DES ALIASES
# =============================================================================
echo -e "${CYAN}ğŸ“ Ã‰TAPE 5/5 : Chargement des alias...${NC}"
if [ -f "$ALIASES_FILES" ]; then
    source "$ALIASES_FILES"
    echo -e "${GREEN}  âœ”ï¸ Alias chargÃ©s${NC}"
else
    echo -e "${YELLOW}  âš ï¸ Fichier $ALIASES_FILES introuvable${NC}"
fi

# =============================================================================
# Ã‰TAPE 6 : CORRECTION AUTOMATIQUE DU CONFLIT GHOSTSCRIPT
# =============================================================================
if [ -f "$DOTFILES_ZSH_PATH/functions/utils/fix_ghostscript_alias.sh" ]; then
    source "$DOTFILES_ZSH_PATH/functions/utils/fix_ghostscript_alias.sh" 2>/dev/null || true
fi

# =============================================================================
# FONCTION DOCUMENTATION INTERACTIVE
# =============================================================================
dotfiles_doc() {
    if [[ -f "$DOTFILES_PATH/scripts/lib/dotfiles_doc.sh" ]]; then
        bash "$DOTFILES_PATH/scripts/lib/dotfiles_doc.sh"
    else
        echo "âŒ Script dotfiles_doc.sh non trouvÃ©"
    fi
}
alias ddoc='dotfiles_doc'
alias doc-dotfiles='dotfiles_doc'

# =============================================================================
# FONCTION BACKUP DOTFILES
# =============================================================================
backup_dotfiles() {
    echo "ğŸ“ Sauvegarde manuelle des dotfiles..."
    ~/auto_backup_dotfiles.sh
    echo "âœ… Sauvegarde terminÃ©e."
}

# =============================================================================
# PROMPT MANJARO AVEC SUPPORT GIT
# =============================================================================
# Charger le prompt Manjaro par dÃ©faut qui inclut l'affichage Git
# Ce prompt affiche la branche Git et le statut dans le prompt
# IMPORTANT: Doit Ãªtre chargÃ© APRÃˆS toutes les autres configurations
if [[ -e /usr/share/zsh/manjaro-zsh-prompt ]]; then
    source /usr/share/zsh/manjaro-zsh-prompt
elif [[ -e /usr/share/zsh/manjaro-zsh-config ]]; then
    # Fallback: charger la config Manjaro si le prompt n'existe pas
    source /usr/share/zsh/manjaro-zsh-config
    if [[ -e /usr/share/zsh/manjaro-zsh-prompt ]]; then
        source /usr/share/zsh/manjaro-zsh-prompt
    fi
fi

# =============================================================================
# FIN DU CHARGEMENT
# =============================================================================
# Neofetch (si installÃ©)
if command -v neofetch >/dev/null 2>&1; then
    neofetch
fi
echo "ğŸ‰ Configuration ZSH personnalisÃ©e chargÃ©e avec succÃ¨s"

