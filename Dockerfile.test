# Dockerfile pour tester l'installation complÃ¨te et automatique des dotfiles
# Environnement minimal et isolÃ© pour tester sans affecter le systÃ¨me hÃ´te
FROM archlinux:latest

# Variables d'environnement pour installation automatique
ENV DOTFILES_DIR=/root/dotfiles
ENV HOME=/root
ENV TERM=xterm-256color
ENV GIT_USER_NAME="Test User"
ENV GIT_USER_EMAIL="test@example.com"
ENV SELECTED_SHELL="zsh"
ENV SKIP_SSH_CONFIG=true

# Installer les dÃ©pendances minimales pour tester
RUN pacman -Syu --noconfirm && \
    pacman -S --noconfirm \
        bash \
        git \
        curl \
        wget \
        zsh \
        sudo \
        which \
        openssh \
        vim \
        python \
        python-pip \
        make \
        base-devel

# CrÃ©er les rÃ©pertoires nÃ©cessaires
RUN mkdir -p /root/.config/moduleman \
    /root/.ssh \
    /root/dotfiles

# Copier les dotfiles dans le conteneur
WORKDIR /root
COPY . ${DOTFILES_DIR}/

# CrÃ©er le script d'installation automatique complÃ¨te
RUN cat > /root/auto-install-test.sh << 'AUTOEOF'
#!/bin/bash
set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info()  { echo -e "${GREEN}[âœ“]${NC} $1"; }
log_warn()  { echo -e "${YELLOW}[!]${NC} $1"; }
log_error() { echo -e "${RED}[âœ—]${NC} $1"; }

cd /root/dotfiles

log_info "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
log_info "TEST D'INSTALLATION AUTOMATIQUE DES DOTFILES"
log_info "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

log_info "Ã‰tape 1/5 : Configuration Git..."
git config --global user.name "${GIT_USER_NAME:-Test User}"
git config --global user.email "${GIT_USER_EMAIL:-test@example.com}"
git config --global init.defaultBranch main
git config --global core.editor vim
git config --global color.ui auto
log_info "âœ“ Git configurÃ©"

log_info "Ã‰tape 2/5 : CrÃ©ation des rÃ©pertoires..."
mkdir -p ~/.config/moduleman
mkdir -p ~/.ssh
mkdir -p ${DOTFILES_DIR}/.config/moduleman
log_info "âœ“ RÃ©pertoires crÃ©Ã©s"

log_info "Ã‰tape 3/5 : CrÃ©ation des symlinks..."
# CrÃ©er les symlinks directement (mode non-interactif pour Docker)
# Ne pas utiliser create_symlinks.sh car il demande des confirmations interactives

# Symlink .zshrc
if [ ! -f ~/.zshrc ] && [ ! -L ~/.zshrc ]; then
    # PrÃ©fÃ©rer le wrapper zshrc qui dÃ©tecte le shell
    if [ -f "${DOTFILES_DIR}/zshrc" ]; then
        ln -s "${DOTFILES_DIR}/zshrc" ~/.zshrc 2>/dev/null || log_warn "Impossible de crÃ©er symlink .zshrc (lecture seule?)"
    elif [ -f "${DOTFILES_DIR}/zsh/zshrc_custom" ]; then
        ln -s "${DOTFILES_DIR}/zsh/zshrc_custom" ~/.zshrc 2>/dev/null || log_warn "Impossible de crÃ©er symlink .zshrc (lecture seule?)"
    fi
    log_info "âœ“ Symlink .zshrc crÃ©Ã©"
elif [ -L ~/.zshrc ]; then
    log_info "âœ“ Symlink .zshrc existe dÃ©jÃ "
else
    log_warn "âš ï¸  Fichier .zshrc existe (pas un symlink), crÃ©ation d'un symlink Ã©chouÃ©e"
fi

# Symlink .gitconfig (optionnel, ne pas Ã©chouer si impossible)
if [ ! -f ~/.gitconfig ] && [ ! -L ~/.gitconfig ]; then
    if [ -f "${DOTFILES_DIR}/.gitconfig" ]; then
        ln -s "${DOTFILES_DIR}/.gitconfig" ~/.gitconfig 2>/dev/null || log_warn "Impossible de crÃ©er symlink .gitconfig"
    fi
fi

# Symlink .p10k.zsh (optionnel)
if [ ! -f ~/.p10k.zsh ] && [ ! -L ~/.p10k.zsh ]; then
    if [ -f "${DOTFILES_DIR}/.p10k.zsh" ]; then
        ln -s "${DOTFILES_DIR}/.p10k.zsh" ~/.p10k.zsh 2>/dev/null || log_warn "Impossible de crÃ©er symlink .p10k.zsh"
    fi
fi

log_info "âœ“ Symlinks crÃ©Ã©s"

log_info "Ã‰tape 4/5 : Configuration ZSH..."
# Si .zshrc est un symlink, il devrait dÃ©jÃ  pointer vers la bonne configuration
# Sinon, essayer de crÃ©er un fichier .zshrc qui source zshrc_custom
if [ -f "${DOTFILES_DIR}/zsh/zshrc_custom" ]; then
    if [ -L ~/.zshrc ]; then
        log_info "âœ“ .zshrc est un symlink, configuration automatique"
    elif [ ! -f ~/.zshrc ]; then
        # Essayer de crÃ©er un fichier .zshrc si possible (peut Ã©chouer si lecture seule)
        {
            echo "# ZSH Configuration"
            echo "source ${DOTFILES_DIR}/zsh/zshrc_custom"
        } > ~/.zshrc 2>/dev/null || {
            log_warn "âš ï¸  Impossible d'Ã©crire dans ~/.zshrc (systÃ¨me de fichiers en lecture seule)"
            log_info "ğŸ’¡ Le symlink devrait Ãªtre crÃ©Ã© automatiquement au prochain dÃ©marrage"
        }
    else
        # Fichier existe mais n'est pas un symlink
        if ! grep -q "source ${DOTFILES_DIR}/zsh/zshrc_custom" ~/.zshrc 2>/dev/null; then
            {
                echo ""
                echo "# Source dotfiles custom configuration"
                echo "source ${DOTFILES_DIR}/zsh/zshrc_custom"
            } >> ~/.zshrc 2>/dev/null || log_warn "âš ï¸  Impossible d'Ã©crire dans ~/.zshrc"
        fi
    fi
    log_info "âœ“ ZSH configurÃ©"
else
    log_warn "zshrc_custom non trouvÃ©"
fi

log_info "Ã‰tape 5/5 : VÃ©rification de l'installation..."
echo ""
log_info "Tests de vÃ©rification :"

# Test 1: VÃ©rifier que les fonctions sont chargÃ©es
if [ -f "${DOTFILES_DIR}/zsh/functions/installman.zsh" ]; then
    log_info "âœ“ installman trouvÃ©"
else
    log_error "âœ— installman non trouvÃ©"
fi

if [ -f "${DOTFILES_DIR}/zsh/functions/configman.zsh" ]; then
    log_info "âœ“ configman trouvÃ©"
else
    log_error "âœ— configman non trouvÃ©"
fi

if [ -f "${DOTFILES_DIR}/Makefile" ]; then
    log_info "âœ“ Makefile trouvÃ©"
else
    log_error "âœ— Makefile non trouvÃ©"
fi

echo ""
log_info "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
log_info "âœ… INSTALLATION AUTOMATIQUE TERMINÃ‰E"
log_info "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
log_info "Pour tester manuellement, lancez:"
echo "  source ~/.zshrc"
echo "  installman"
echo "  configman"
echo ""
AUTOEOF

RUN chmod +x /root/auto-install-test.sh

# Script de test automatique qui vÃ©rifie que tout fonctionne
RUN cat > /root/test-verification.sh << 'TESTEOF'
#!/bin/bash
set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info()  { echo -e "${GREEN}[âœ“]${NC} $1"; }
log_error() { echo -e "${RED}[âœ—]${NC} $1"; }

cd /root/dotfiles

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "VÃ‰RIFICATION AUTOMATIQUE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Charger la configuration ZSH
source ~/.zshrc 2>/dev/null || true

# Test 1: VÃ©rifier que installman est disponible
if type installman >/dev/null 2>&1; then
    log_info "âœ“ installman disponible"
else
    log_error "âœ— installman non disponible"
fi

# Test 2: VÃ©rifier que configman est disponible
if type configman >/dev/null 2>&1; then
    log_info "âœ“ configman disponible"
else
    log_error "âœ— configman non disponible"
fi

# Test 3: VÃ©rifier que les managers sont chargÃ©s
MANAGERS=("pathman" "netman" "gitman" "moduleman")
for manager in "${MANAGERS[@]}"; do
    if type "$manager" >/dev/null 2>&1; then
        log_info "âœ“ $manager disponible"
    else
        log_error "âœ— $manager non disponible"
    fi
done

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
TESTEOF

RUN chmod +x /root/test-verification.sh

# Commande par dÃ©faut : lancer l'installation automatique puis les tests
CMD ["/bin/bash", "-c", "/root/auto-install-test.sh && /root/test-verification.sh && echo '' && echo 'ğŸ‰ Tests terminÃ©s! Lancez /bin/zsh pour un shell interactif' && /bin/zsh"]
