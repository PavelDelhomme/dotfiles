# Dockerfile pour tester l'installation complÃ¨te et automatique des dotfiles
# Environnement minimal et isolÃ© pour tester sans affecter le systÃ¨me hÃ´te
FROM archlinux:latest

# Variables d'environnement pour installation automatique
ENV DOTFILES_DIR=/root/dotfiles
ENV HOME=/root
ENV TERM=xterm-256color
ENV GIT_USER_NAME="Test User"
ENV GIT_USER_EMAIL="test@example.com"
ARG SELECTED_SHELL="zsh"
ENV SELECTED_SHELL=${SELECTED_SHELL}
ENV SKIP_SSH_CONFIG=true

# Installer les dÃ©pendances minimales pour tester (tous les shells)
RUN pacman -Syu --noconfirm && \
    pacman -S --noconfirm \
        bash \
        git \
        curl \
        wget \
        zsh \
        fish \
        sudo \
        which \
        openssh \
        vim \
        python \
        python-pip \
        make \
        base-devel

# CrÃ©er les rÃ©pertoires nÃ©cessaires
RUN mkdir -p /root/.config/moduleman \
    /root/.ssh \
    /root/dotfiles

# Argument de build pour la configuration des managers
ARG MANAGERS_CONFIG=""

# Copier les dotfiles dans le conteneur
WORKDIR /root
COPY . ${DOTFILES_DIR}/

# CrÃ©er le script d'installation automatique complÃ¨te
RUN cat > /root/auto-install-test.sh << 'AUTOEOF'
#!/bin/bash
# Utiliser set -e pour arrÃªter sur erreurs critiques, mais continuer pour les avertissements
set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info()  { echo -e "${GREEN}[âœ“]${NC} $1"; }
log_warn()  { echo -e "${YELLOW}[!]${NC} $1"; }
log_error() { echo -e "${RED}[âœ—]${NC} $1"; }

cd /root/dotfiles

log_info "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
log_info "TEST D'INSTALLATION AUTOMATIQUE DES DOTFILES"
log_info "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

log_info "Ã‰tape 1/5 : Configuration Git..."
git config --global user.name "${GIT_USER_NAME:-Test User}"
git config --global user.email "${GIT_USER_EMAIL:-test@example.com}"
git config --global init.defaultBranch main
git config --global core.editor vim
git config --global color.ui auto
log_info "âœ“ Git configurÃ©"

log_info "Ã‰tape 2/5 : CrÃ©ation des rÃ©pertoires et configuration des managers..."
mkdir -p ~/.config/moduleman
mkdir -p ~/.ssh
# Ne pas crÃ©er dans DOTFILES_DIR car c'est en lecture seule dans Docker
# CrÃ©er dans ~/.config/moduleman Ã  la place

# CrÃ©er le fichier de configuration des managers dans ~/.config/moduleman
# (pas dans DOTFILES_DIR car le volume est en lecture seule)
if [ -n "${MANAGERS_CONFIG}" ]; then
    echo "${MANAGERS_CONFIG}" > ~/.config/moduleman/modules.conf
    log_info "âœ“ Configuration des managers crÃ©Ã©e depuis build arg"
else
    # Configuration par dÃ©faut (tous activÃ©s)
    cat > ~/.config/moduleman/modules.conf << 'MODULES_EOF'
# Configuration des modules - Moduleman
# Format compatible Zsh et Fish
# Tous les modules sont activÃ©s par dÃ©faut

MODULE_pathman=enabled
MODULE_netman=enabled
MODULE_aliaman=enabled
MODULE_miscman=enabled
MODULE_searchman=enabled
MODULE_cyberman=enabled
MODULE_devman=enabled
MODULE_gitman=enabled
MODULE_helpman=enabled
MODULE_manman=enabled
MODULE_configman=enabled
MODULE_installman=enabled
MODULE_moduleman=enabled
MODULE_fileman=enabled
MODULE_virtman=enabled
MODULE_sshman=enabled
MODULE_testzshman=enabled
MODULE_testman=enabled
MODULES_EOF
    log_info "âœ“ Configuration par dÃ©faut crÃ©Ã©e (tous activÃ©s)"
fi
log_info "âœ“ RÃ©pertoires crÃ©Ã©s"

log_info "Ã‰tape 3/5 : CrÃ©ation des symlinks..."
# CrÃ©er les symlinks directement (mode non-interactif pour Docker)
# Ne pas utiliser create_symlinks.sh car il demande des confirmations interactives

# Symlink .zshrc
if [ ! -f ~/.zshrc ] && [ ! -L ~/.zshrc ]; then
    # PrÃ©fÃ©rer le wrapper zshrc qui dÃ©tecte le shell
    if [ -f "${DOTFILES_DIR}/zshrc" ]; then
        ln -s "${DOTFILES_DIR}/zshrc" ~/.zshrc 2>/dev/null || log_warn "Impossible de crÃ©er symlink .zshrc (lecture seule?)"
    elif [ -f "${DOTFILES_DIR}/zsh/zshrc_custom" ]; then
        ln -s "${DOTFILES_DIR}/zsh/zshrc_custom" ~/.zshrc 2>/dev/null || log_warn "Impossible de crÃ©er symlink .zshrc (lecture seule?)"
    fi
    log_info "âœ“ Symlink .zshrc crÃ©Ã©"
elif [ -L ~/.zshrc ]; then
    log_info "âœ“ Symlink .zshrc existe dÃ©jÃ "
else
    log_warn "âš ï¸  Fichier .zshrc existe (pas un symlink), crÃ©ation d'un symlink Ã©chouÃ©e"
fi

# Symlink .gitconfig (optionnel, ne pas Ã©chouer si impossible)
if [ ! -f ~/.gitconfig ] && [ ! -L ~/.gitconfig ]; then
    if [ -f "${DOTFILES_DIR}/.gitconfig" ]; then
        ln -s "${DOTFILES_DIR}/.gitconfig" ~/.gitconfig 2>/dev/null || log_warn "Impossible de crÃ©er symlink .gitconfig"
    fi
fi

# Symlink .p10k.zsh (optionnel)
if [ ! -f ~/.p10k.zsh ] && [ ! -L ~/.p10k.zsh ]; then
    if [ -f "${DOTFILES_DIR}/.p10k.zsh" ]; then
        ln -s "${DOTFILES_DIR}/.p10k.zsh" ~/.p10k.zsh 2>/dev/null || log_warn "Impossible de crÃ©er symlink .p10k.zsh"
    fi
fi

log_info "âœ“ Symlinks crÃ©Ã©s"

log_info "Ã‰tape 4/5 : Configuration du shell (${SELECTED_SHELL:-zsh})..."
# Configurer selon le shell choisi via build arg
SELECTED_SHELL="${SELECTED_SHELL:-zsh}"

case "$SELECTED_SHELL" in
    zsh)
        # Configuration ZSH (toutes les fonctionnalitÃ©s)
        if [ -f "${DOTFILES_DIR}/zsh/zshrc_custom" ]; then
            if [ -L ~/.zshrc ]; then
                log_info "âœ“ .zshrc est un symlink, configuration automatique"
            elif [ ! -f ~/.zshrc ]; then
                if [ -f "${DOTFILES_DIR}/zshrc" ]; then
                    ln -s "${DOTFILES_DIR}/zshrc" ~/.zshrc 2>/dev/null || log_warn "Impossible de crÃ©er symlink .zshrc"
                else
                    {
                        echo "# ZSH Configuration"
                        echo "source ${DOTFILES_DIR}/zsh/zshrc_custom"
                    } > ~/.zshrc 2>/dev/null || log_warn "âš ï¸  Impossible d'Ã©crire dans ~/.zshrc"
                fi
            fi
            log_info "âœ“ ZSH configurÃ© (toutes les fonctionnalitÃ©s - 18 managers disponibles)"
        else
            log_warn "zshrc_custom non trouvÃ©"
        fi
        ;;
    bash)
        # Configuration Bash (compatibilitÃ© basique)
        if [ ! -f ~/.bashrc ] || ! grep -q "dotfiles" ~/.bashrc 2>/dev/null; then
            {
                echo ""
                echo "# Dotfiles configuration (compatibilitÃ© Bash)"
                if [ -f "${DOTFILES_DIR}/zshrc" ]; then
                    echo "source ${DOTFILES_DIR}/zshrc"
                elif [ -f "${DOTFILES_DIR}/zsh/env.sh" ]; then
                    echo "source ${DOTFILES_DIR}/zsh/env.sh"
                fi
            } >> ~/.bashrc 2>/dev/null || log_warn "âš ï¸  Impossible d'Ã©crire dans ~/.bashrc"
        fi
        log_info "âœ“ Bash configurÃ© (mode compatibilitÃ© basique - variables d'env et alias simples)"
        log_warn "âš ï¸  Les managers interactifs (*man) ne sont pas disponibles en Bash (ZSH-only)"
        ;;
    fish)
        # Configuration Fish (compatibilitÃ© basique)
        mkdir -p ~/.config/fish
        if [ ! -f ~/.config/fish/config.fish ] || ! grep -q "dotfiles" ~/.config/fish/config.fish 2>/dev/null; then
            {
                echo ""
                echo "# Dotfiles configuration (compatibilitÃ© Fish)"
                if [ -f "${DOTFILES_DIR}/fish/config_custom.fish" ]; then
                    echo "source ${DOTFILES_DIR}/fish/config_custom.fish"
                fi
            } >> ~/.config/fish/config.fish 2>/dev/null || log_warn "âš ï¸  Impossible d'Ã©crire dans ~/.config/fish/config.fish"
        fi
        log_info "âœ“ Fish configurÃ© (mode compatibilitÃ© basique - variables d'env et alias)"
        log_warn "âš ï¸  Les managers interactifs (*man) ne sont pas disponibles en Fish (ZSH-only)"
        ;;
    *)
        log_warn "âš ï¸  Shell non reconnu: $SELECTED_SHELL, utilisation de ZSH par dÃ©faut"
        SELECTED_SHELL="zsh"
        ;;
esac

log_info "Ã‰tape 5/5 : VÃ©rification de l'installation..."
echo ""
log_info "Tests de vÃ©rification :"

# Test 1: VÃ©rifier que les fonctions sont chargÃ©es
if [ -f "${DOTFILES_DIR}/zsh/functions/installman.zsh" ]; then
    log_info "âœ“ installman trouvÃ©"
else
    log_error "âœ— installman non trouvÃ©"
fi

if [ -f "${DOTFILES_DIR}/zsh/functions/configman.zsh" ]; then
    log_info "âœ“ configman trouvÃ©"
else
    log_error "âœ— configman non trouvÃ©"
fi

if [ -f "${DOTFILES_DIR}/Makefile" ]; then
    log_info "âœ“ Makefile trouvÃ©"
else
    log_error "âœ— Makefile non trouvÃ©"
fi

echo ""
log_info "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
log_info "âœ… INSTALLATION AUTOMATIQUE TERMINÃ‰E"
log_info "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
log_info "Pour tester manuellement, lancez:"
echo "  source ~/.zshrc"
echo "  installman"
echo "  configman"
echo ""
# Toujours retourner 0 pour indiquer que l'installation s'est bien passÃ©e
exit 0
AUTOEOF

RUN chmod +x /root/auto-install-test.sh

# Script de test automatique qui vÃ©rifie que tout fonctionne
RUN cat > /root/test-verification.sh << 'TESTEOF'
#!/bin/bash
# Ne pas utiliser set -e pour permettre de continuer mÃªme si certains tests Ã©chouent
set +e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info()  { echo -e "${GREEN}[âœ“]${NC} $1"; }
log_error() { echo -e "${RED}[âœ—]${NC} $1"; }
log_warn()  { echo -e "${YELLOW}[!]${NC} $1"; }

cd /root/dotfiles

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "VÃ‰RIFICATION AUTOMATIQUE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Test 1: VÃ©rifier que les fichiers des managers existent
log_info "VÃ©rification des fichiers des managers..."
MANAGER_FILES=(
    "zsh/functions/aliaman.zsh:aliaman"
    "zsh/functions/configman.zsh:configman"
    "zsh/functions/cyberman.zsh:cyberman"
    "zsh/functions/devman.zsh:devman"
    "zsh/functions/fileman.zsh:fileman"
    "zsh/functions/gitman.zsh:gitman"
    "zsh/functions/helpman.zsh:helpman"
    "zsh/functions/installman.zsh:installman"
    "zsh/functions/manman.zsh:manman"
    "zsh/functions/miscman.zsh:miscman"
    "zsh/functions/moduleman.zsh:moduleman"
    "zsh/functions/netman.zsh:netman"
    "zsh/functions/pathman.zsh:pathman"
    "zsh/functions/searchman.zsh:searchman"
    "zsh/functions/sshman.zsh:sshman"
    "zsh/functions/testman.zsh:testman"
    "zsh/functions/testzshman.zsh:testzshman"
    "zsh/functions/virtman.zsh:virtman"
)

for file_manager in "${MANAGER_FILES[@]}"; do
    file="${file_manager%%:*}"
    manager="${file_manager##*:}"
    if [ -f "${DOTFILES_DIR}/${file}" ]; then
        log_info "âœ“ Fichier $manager trouvÃ©: $file"
    else
        log_error "âœ— Fichier $manager non trouvÃ©: $file"
    fi
done

echo ""
log_info "VÃ©rification du chargement dans ZSH..."
# Tester dans ZSH car les managers sont des fonctions ZSH
if command -v zsh >/dev/null 2>&1; then
    # CrÃ©er un script temporaire pour tester dans ZSH
    cat > /tmp/test-zsh-managers.sh << 'ZSH_TEST'
#!/bin/zsh
set +e  # Ne pas arrÃªter sur erreurs

DOTFILES_DIR="${DOTFILES_DIR:-/root/dotfiles}"

# Charger la configuration ZSH en silence
if [ -f ~/.zshrc ]; then
    # Rediriger tous les outputs pour Ã©viter les messages pendant le chargement
    source ~/.zshrc >/dev/null 2>&1 || true
fi

# Attendre un peu pour que tout soit chargÃ©
sleep 0.5

# Test des managers dans ZSH (tous les managers disponibles)
MANAGERS=("aliaman" "configman" "cyberman" "devman" "fileman" "gitman" "helpman" "installman" "manman" "miscman" "moduleman" "netman" "pathman" "searchman" "sshman" "testman" "testzshman" "virtman")
SUCCESS=0
FAILED=0

for manager in "${MANAGERS[@]}"; do
    if type "$manager" >/dev/null 2>&1; then
        echo "[âœ“] $manager disponible"
        ((SUCCESS++))
    else
        echo "[âœ—] $manager non disponible"
        # Diagnostic pour testman
        if [ "$manager" = "testman" ]; then
            echo "    Debug testman:"
            echo "    - DOTFILES_DIR: ${DOTFILES_DIR:-non dÃ©fini}"
            echo "    - Fichier wrapper: $([ -f /root/dotfiles/zsh/functions/testman.zsh ] && echo 'existe' || echo 'manquant')"
            echo "    - Fichier core: $([ -f /root/dotfiles/zsh/functions/testman/core/testman.zsh ] && echo 'existe' || echo 'manquant')"
            # Essayer de charger manuellement avec capture d'erreurs
            if [ -f /root/dotfiles/zsh/functions/testman.zsh ]; then
                echo "    - Tentative chargement manuel..."
                ERROR_OUTPUT=$(source /root/dotfiles/zsh/functions/testman.zsh 2>&1)
                ERROR_CODE=$?
                if [ -n "$ERROR_OUTPUT" ]; then
                    echo "    - Erreur: $ERROR_OUTPUT" | head -3
                fi
                if [ $ERROR_CODE -ne 0 ]; then
                    echo "    - Code de sortie: $ERROR_CODE"
                fi
                # VÃ©rifier si la fonction existe maintenant
                if type testman >/dev/null 2>&1; then
                    echo "    - âœ“ Chargement manuel rÃ©ussi!"
                else
                    echo "    - âœ— Chargement manuel Ã©chouÃ©"
                    # VÃ©rifier si le core peut Ãªtre chargÃ© directement
                    echo "    - Test chargement core direct..."
                    CORE_ERROR=$(source /root/dotfiles/zsh/functions/testman/core/testman.zsh 2>&1)
                    if [ -n "$CORE_ERROR" ]; then
                        echo "    - Erreur core: $CORE_ERROR" | head -3
                    fi
                    if type testman >/dev/null 2>&1; then
                        echo "    - âœ“ Chargement core direct rÃ©ussi!"
                    else
                        echo "    - âœ— Chargement core direct Ã©chouÃ©"
                    fi
                fi
            fi
        fi
        ((FAILED++))
    fi
done

echo ""
if [ $FAILED -eq 0 ]; then
    echo "[âœ“] RÃ©sumÃ©: Tous les $SUCCESS managers sont disponibles"
    exit 0
else
    echo "[!] RÃ©sumÃ©: $SUCCESS disponibles, $FAILED manquants"
    exit $FAILED
fi
ZSH_TEST
    
    chmod +x /tmp/test-zsh-managers.sh
    
    # ExÃ©cuter le test dans ZSH et capturer la sortie
    TEST_OUTPUT=$(zsh /tmp/test-zsh-managers.sh 2>&1)
    TEST_EXIT=$?
    
    # Afficher la sortie du test
    echo "$TEST_OUTPUT"
    
    if [ $TEST_EXIT -eq 0 ]; then
        log_info "âœ“ Tous les managers sont disponibles dans ZSH"
    else
        log_warn "âš ï¸  Certains managers ne sont pas disponibles dans ZSH"
        log_warn "   (Cela peut Ãªtre normal si la configuration n'est pas complÃ¨tement chargÃ©e)"
        log_warn "   Essayez de lancer 'zsh' manuellement pour tester"
    fi
    
    rm -f /tmp/test-zsh-managers.sh
else
    log_warn "âš ï¸  ZSH non disponible pour les tests (peut Ãªtre normal)"
fi

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
log_info "âœ… VÃ©rification terminÃ©e"
echo ""
TESTEOF

RUN chmod +x /root/test-verification.sh

# Script de test fonctionnel complet des managers (multi-shells)
RUN cat > /root/test-managers-functional.sh << 'FUNCTIONAL_TEST'
#!/bin/bash
# Ne pas utiliser set -e pour permettre de continuer mÃªme si certains tests Ã©chouent
set +e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info()  { echo -e "${GREEN}[âœ“]${NC} $1"; }
log_error() { echo -e "${RED}[âœ—]${NC} $1"; }
log_warn()  { echo -e "${YELLOW}[!]${NC} $1"; }
log_test()  { echo -e "${BLUE}[â†’]${NC} $1"; }
log_shell() { echo -e "${CYAN}[ğŸš]${NC} $1"; }

cd /root/dotfiles

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "TESTS FONCTIONNELS DES MANAGERS (MULTI-SHELLS)"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Managers convertis Ã  tester spÃ©cifiquement
CONVERTED_MANAGERS=("installman" "configman" "pathman" "manman")

# Fonction pour tester un manager dans un shell
test_manager_in_shell() {
    local shell="$1"
    local manager="$2"
    local shell_cmd=""
    local config_file=""
    
    case "$shell" in
        zsh)
            shell_cmd="/bin/zsh"
            config_file="~/.zshrc"
            ;;
        bash)
            shell_cmd="/bin/bash"
            config_file="~/.bashrc"
            ;;
        fish)
            shell_cmd="/usr/bin/fish"
            config_file="~/.config/fish/config.fish"
            ;;
        *)
            log_error "Shell non reconnu: $shell"
            return 1
            ;;
    esac
    
    # CrÃ©er un script de test pour ce shell
    cat > /tmp/test-$manager-$shell.sh << EOF
#!/bin/bash
# Test de $manager dans $shell
set +e

# Charger la configuration du shell
if [ -f $config_file ]; then
    if [ "$shell" = "fish" ]; then
        $shell_cmd -c "source $config_file >/dev/null 2>&1; type $manager >/dev/null 2>&1 && echo 'OK' || echo 'FAIL'"
    else
        $shell_cmd -c "source $config_file >/dev/null 2>&1; type $manager >/dev/null 2>&1 && echo 'OK' || echo 'FAIL'"
    fi
else
    echo "FAIL"
fi
EOF
    chmod +x /tmp/test-$manager-$shell.sh
    
    # ExÃ©cuter le test
    if [ "$shell" = "fish" ]; then
        RESULT=$(fish /tmp/test-$manager-$shell.sh 2>/dev/null)
    else
        RESULT=$(bash /tmp/test-$manager-$shell.sh 2>/dev/null)
    fi
    
    rm -f /tmp/test-$manager-$shell.sh
    
    if [ "$RESULT" = "OK" ]; then
        echo "[âœ“] $manager disponible dans $shell"
        return 0
    else
        echo "[âœ—] $manager non disponible dans $shell"
        return 1
    fi
}

# Tester les managers convertis dans les 3 shells
echo ""
log_shell "Test des managers convertis dans les 3 shells..."
echo ""

for manager in "${CONVERTED_MANAGERS[@]}"; do
    log_test "Test $manager..."
    echo "  ZSH:   $(test_manager_in_shell zsh "$manager" && echo 'âœ“' || echo 'âœ—')"
    echo "  Bash:  $(test_manager_in_shell bash "$manager" && echo 'âœ“' || echo 'âœ—')"
    echo "  Fish:  $(test_manager_in_shell fish "$manager" && echo 'âœ“' || echo 'âœ—')"
    echo ""
done

# CrÃ©er un script ZSH pour tester les managers
cat > /tmp/test-managers-zsh.sh << 'ZSH_FUNCTIONAL_TEST'
#!/bin/zsh
set +e  # Ne pas arrÃªter sur erreurs

DOTFILES_DIR="${DOTFILES_DIR:-/root/dotfiles}"

# Charger la configuration ZSH
if [ -f ~/.zshrc ]; then
    source ~/.zshrc >/dev/null 2>&1 || true
fi

# Attendre un peu pour que tout soit chargÃ©
sleep 0.5

TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

# Fonction pour tester un manager
test_manager() {
    local manager="$1"
    local test_command="$2"
    local expected_output="$3"
    
    ((TOTAL_TESTS++))
    
    # VÃ©rifier que le manager existe
    if ! type "$manager" >/dev/null 2>&1; then
        echo "[âœ—] $manager: non disponible"
        ((FAILED_TESTS++))
        return 1
    fi
    
    # Tester la commande
    if [ -n "$test_command" ]; then
        # Utiliser timeout pour Ã©viter que les menus interactifs bloquent
        TEST_OUTPUT=$(eval "$test_command" 2>&1)
        TEST_EXIT=$?
        
        # Pour les commandes avec timeout, le code de sortie peut Ãªtre 124 (timeout)
        # C'est normal pour les menus interactifs, on considÃ¨re que c'est un succÃ¨s
        if [ $TEST_EXIT -eq 0 ] || [ $TEST_EXIT -eq 124 ]; then
            if [ -z "$expected_output" ] || echo "$TEST_OUTPUT" | grep -q "$expected_output"; then
                echo "[âœ“] $manager: fonctionne correctement"
                ((PASSED_TESTS++))
                return 0
            else
                # Si pas de sortie attendue spÃ©cifique, vÃ©rifier qu'il y a une sortie (menu affichÃ©)
                if [ -z "$expected_output" ] && [ -n "$TEST_OUTPUT" ]; then
                    echo "[âœ“] $manager: fonctionne correctement (menu affichÃ©)"
                    ((PASSED_TESTS++))
                    return 0
                else
                    echo "[âœ—] $manager: sortie inattendue"
                    ((FAILED_TESTS++))
                    return 1
                fi
            fi
        else
            echo "[âœ—] $manager: erreur lors de l'exÃ©cution (code: $TEST_EXIT)"
            ((FAILED_TESTS++))
            return 1
        fi
    else
        # Juste vÃ©rifier que le manager peut Ãªtre appelÃ©
        if "$manager" --help >/dev/null 2>&1 || "$manager" help >/dev/null 2>&1 || "$manager" list >/dev/null 2>&1; then
            echo "[âœ“] $manager: disponible et appelable"
            ((PASSED_TESTS++))
            return 0
        else
            # Certains managers peuvent ne pas avoir --help, tester juste l'appel
            if "$manager" >/dev/null 2>&1; then
                echo "[âœ“] $manager: disponible et appelable"
                ((PASSED_TESTS++))
                return 0
            else
                echo "[âœ—] $manager: erreur lors de l'appel"
                ((FAILED_TESTS++))
                return 1
            fi
        fi
    fi
}

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "TESTS FONCTIONNELS DES MANAGERS"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Tester chaque manager avec ses fonctions spÃ©cifiques
log_test "Test installman (list)..."
test_manager "installman" "installman list" "Outils disponibles"

log_test "Test configman (appel)..."
test_manager "configman" "timeout 2 configman || true" ""

log_test "Test pathman (show)..."
test_manager "pathman" "pathman show 2>/dev/null || pathman" ""

log_test "Test netman (appel)..."
test_manager "netman" "timeout 2 netman || true" ""

log_test "Test gitman (appel)..."
test_manager "gitman" "timeout 2 gitman || true" ""

log_test "Test moduleman (appel)..."
test_manager "moduleman" "timeout 2 moduleman || true" ""

log_test "Test fileman (appel)..."
test_manager "fileman" "timeout 2 fileman || true" ""

log_test "Test sshman (appel)..."
test_manager "sshman" "timeout 2 sshman || true" ""

log_test "Test testzshman (appel)..."
test_manager "testzshman" "timeout 2 testzshman || true" ""

log_test "Test testman (appel)..."
test_manager "testman" "timeout 2 testman || true" ""

log_test "Test aliaman (appel)..."
test_manager "aliaman" "timeout 2 aliaman || true" ""

log_test "Test cyberman (appel)..."
test_manager "cyberman" "timeout 2 cyberman || true" ""

log_test "Test devman (appel)..."
test_manager "devman" "timeout 2 devman || true" ""

log_test "Test helpman (appel)..."
test_manager "helpman" "timeout 2 helpman || true" ""

log_test "Test manman (appel)..."
test_manager "manman" "timeout 2 manman || true" ""

log_test "Test miscman (appel)..."
test_manager "miscman" "timeout 2 miscman || true" ""

log_test "Test searchman (appel)..."
test_manager "searchman" "timeout 2 searchman || true" ""

log_test "Test virtman (appel)..."
test_manager "virtman" "timeout 2 virtman || true" ""

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "RÃ‰SUMÃ‰ DES TESTS FONCTIONNELS"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "Total: $TOTAL_TESTS tests"
echo "RÃ©ussis: $PASSED_TESTS"
echo "Ã‰chouÃ©s: $FAILED_TESTS"
echo ""

if [ $FAILED_TESTS -eq 0 ]; then
    echo "[âœ“] Tous les managers fonctionnent correctement!"
    exit 0
else
    echo "[!] $FAILED_TESTS manager(s) ont des problÃ¨mes"
    exit $FAILED_TESTS
fi
ZSH_FUNCTIONAL_TEST

chmod +x /tmp/test-managers-zsh.sh

# ExÃ©cuter le test dans ZSH
log_info "ExÃ©cution des tests fonctionnels dans ZSH..."
TEST_OUTPUT=$(zsh /tmp/test-managers-zsh.sh 2>&1)
TEST_EXIT=$?

# Afficher la sortie du test
echo "$TEST_OUTPUT"

if [ $TEST_EXIT -eq 0 ]; then
    log_info "âœ“ Tous les tests fonctionnels ont rÃ©ussi"
else
    log_warn "âš ï¸  Certains tests fonctionnels ont Ã©chouÃ©"
    log_warn "   (Cela peut Ãªtre normal si certains managers nÃ©cessitent une configuration spÃ©cifique)"
fi

rm -f /tmp/test-managers-zsh.sh

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
# Toujours retourner 0 pour ne pas faire Ã©chouer le conteneur
exit 0
FUNCTIONAL_TEST

RUN chmod +x /root/test-managers-functional.sh

# Commande par dÃ©faut : lancer l'installation automatique puis les tests
# Ne pas lancer zsh automatiquement car le conteneur peut ne pas Ãªtre interactif
CMD ["/bin/bash", "-c", "/root/auto-install-test.sh && /root/test-verification.sh && /root/test-managers-functional.sh && echo '' && echo 'ğŸ‰ Tests terminÃ©s!' && echo '' && echo 'ğŸ’¡ Pour tester manuellement, lancez:' && echo '   make docker-start' && echo '   (Plus simple que docker exec !)' && echo ''"]

